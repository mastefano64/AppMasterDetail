***Introduzione: Asserzioni Implicite vs. Esplicite in Cypress - Should vs. Expect

Nell'ambito dei test end-to-end con Cypress, le asserzioni svolgono un ruolo cruciale nel garantire che il tuo sito web o la tua applicazione web rispettino le condizioni desiderate. Tuttavia, Cypress offre diverse modalità di gestione delle asserzioni, tra cui asserzioni implicite e esplicite. Inoltre, hai a disposizione le costruzioni .should() e .expect() per scrivere asserzioni personalizzate.

Questo articolo esplorerà le differenze tra asserzioni implicite ed esplicite in Cypress e discuterà quando è opportuno utilizzare .should() e .expect(). Comprenderai come queste diverse approcci possano influenzare il tuo flusso di lavoro di test end-to-end e come scegliere la modalità più appropriata in base alle tue esigenze specifiche.

Asserzioni Implicite e Esplicite
Le asserzioni implicite e esplicite in Cypress differiscono nella gestione del timeout e nel comportamento in caso di fallimento delle asserzioni:

Assezioni Implicite: Le asserzioni implicite sono spesso gestite con .should(). In questo caso, Cypress cercherà di ritentare l'asserzione fino a quando questa non riesce o scade il timeout. Questo è utile quando desideri attendere che un'asserzione abbia successo con ritentativi, ad esempio quando si aspetta che un elemento diventi visibile o cambino le sue proprietà.

Assezioni Esplicite: Le asserzioni esplicite sono implementate con .expect(). Se un'asserzione fallisce all'interno di .expect(), il test fallirà immediatamente senza ulteriori tentativi. Questo è utile quando vuoi che il test fallisca se l'asserzione non ha successo, senza aspettare inutilmente.

Continua a leggere per scoprire le situazioni in cui ognuna di queste modalità è più appropriata e come utilizzare .should() e .expect() efficacemente nei tuoi test Cypress.

***Utilizzo delle Asserzioni in Cypress
In Cypress, le asserzioni sono fondamentali per verificare che il tuo sito web o la tua applicazione web rispettino le condizioni desiderate. Puoi concatenare comandi .should() uno dopo l'altro per eseguire diverse asserzioni su un elemento selezionato. Questo è un modo comune per verificare più condizioni su un elemento specifico. Ad esempio:

javascript
Copy code
cy.get('element-selector')
  .should('have.class', 'some-class')
  .should('be.visible')
  .should('have.text', 'Some Text');
In questo esempio, stiamo verificando tre condizioni diverse sull'elemento selezionato in sequenza.

Tuttavia, l'uso di .and() è utile quando desideri applicare più di un criterio in una singola asserzione. Ad esempio, se desideri verificare che un elemento abbia una certa classe CSS e sia visibile in un'unica asserzione, puoi farlo con .and():

javascript
Copy code
cy.get('element-selector')
  .should('have.class', 'some-class')
  .and('be.visible');
.and() viene utilizzato per concatenare più condizioni all'interno di un'unica asserzione. Se usi .and() senza aver utilizzato prima .should(), Cypress non saprà su cosa eseguire l'asserzione, poiché .and() deve essere utilizzato in combinazione con un'asserzione precedente per specificare l'elemento su cui applicare le condizioni aggiuntive.

In generale, la scelta tra l'uso di .should() e .and() dipende dalla logica specifica dei tuoi test e dalle tue esigenze di verifica delle condizioni. Puoi usarli in combinazione per creare asserzioni complesse e dettagliate, ma è importante assicurarsi di specificare correttamente l'elemento su cui applicare le asserzioni.

Asserzioni Separate con .should()
Nel runner di Cypress, ogni .should() rappresenta un'asserzione separata. Quando concateni più .should() uno dopo l'altro, ciascuno di essi rappresenta una condizione separata che deve essere verificata. Ad esempio:

javascript
Copy code
cy.get('element-selector')
  .should('have.class', 'some-class')
  .should('be.visible')
  .should('have.text', 'Some Text');
Nell'esempio sopra, ci sono tre asserzioni separate, e il test avrà successo solo se tutte e tre le asserzioni sono verificate positivamente. Se anche una sola di queste asserzioni fallisce, il test verrà considerato fallito.

Asserzioni Composte con .and()
D'altro canto, quando utilizzi .and(), stai creando una singola asserzione composta che verifica più condizioni insieme. Ad esempio:

javascript
Copy code
cy.get('element-selector')
  .should('have.class', 'some-class')
  .and('be.visible');
In questo caso, entrambe le condizioni devono essere verificate con successo affinché il test venga superato. L'utilizzo di .and() in questo contesto crea un'asserzione composta che verifica più condizioni in un'unica asserzione.

In breve, sia .should() che .and() rappresentano asserzioni, ma .should() crea asserzioni separate, mentre .and() crea un'unica asserzione composta con più condizioni. La scelta di come utilizzare queste costruzioni dipenderà dalla logica dei tuoi test e dalle tue esigenze di verifica delle condizioni.

L'utilizzo di .then(callback) e .should(callback)
Puoi scrivere asserzioni personalizzate all'interno delle funzioni di callback di .then(callback) o .should(callback). La differenza principale tra questi due approcci riguarda il comportamento in caso di fallimento delle asserzioni.

.should(callback): Quando utilizzi .should(callback) con una funzione di callback che contiene asserzioni, Cypress cercherà di ritentare l'asserzione fino a quando questa non riesce o fino a quando scade il timeout. È utile quando desideri attendere che un'asserzione abbia successo con ritentativi, ad esempio, quando si aspetta che un elemento diventi visibile o cambino le sue proprietà.

.then(callback): Con .then(callback), se un'asserzione fallisce all'interno della funzione di callback, il test fallirà immediatamente senza ulteriori tentativi. Questo è utile quando vuoi che il test fallisca se l'asserzione non ha successo, senza aspettare inutilmente.

In generale, puoi scegliere tra .should(callback) e .then(callback) in base alle tue esigenze. Se hai bisogno di aspettare che un'asserzione abbia successo e vuoi che Cypress ritenti fino a quando l'asserzione non passa, allora .should(callback) è la scelta appropriata. Se, d'altro canto, desideri un comportamento più rigido e vuoi che il test fallisca immediatamente in caso di fallimento dell'asserzione, allora .then(callback) è la scelta da fare.

Utilizzo di cy.wrap()
cy.wrap() è utile quando desideri avvolgere un oggetto JavaScript puro in un oggetto Cypress in modo da poter applicare comandi Cypress su di esso, anche se non stai partendo da una query cy.get() o dal risultato di operazioni su di essa. Ad esempio, se hai un oggetto JavaScript come { name: 'Joe' } e desideri effettuare asserzioni o eseguire operazioni su di esso utilizzando Cypress, puoi utilizzare cy.wrap() per avvolgerlo e quindi eseguire comandi Cypress su di esso. È utile quando hai bisogno di interagire con dati o oggetti non correlati direttamente all'interazione con la pagina web.

Ecco un esempio di utilizzo di cy.wrap():

javascript
Copy code
cy.wrap({ name: 'Joe' }).should((o) => {
  expect(o).to.have.property('name', 'Joe');
});
In questo caso, cy.wrap({ name: 'Joe' }) avvolge l'oggetto JavaScript in un oggetto Cypress, consentendo l'utilizzo di comandi Cypress come .should() su di esso.

Tieni presente che è preferibile utilizzare cy.get() quando puoi ottenere gli elementi direttamente dalla pagina web, ma cy.wrap() è utile per lavorare con dati o oggetti non correlati all'interazione con la pagina web.

***Aspetti Importanti delle Asserzioni in Cypress: Regola "All" vs. "Any"

Nell'ecosistema di test di Cypress, le asserzioni giocano un ruolo cruciale nell'assicurarsi che il tuo sito web o la tua applicazione web funzionino correttamente. Tuttavia, non tutte le asserzioni sono valutate allo stesso modo. In realtà, Cypress utilizza due approcci chiave per valutare le asserzioni: "all" e "any". Vediamo come queste regole influenzano diverse asserzioni in Cypress.

Regola "All" - Asserzioni Negative
Le asserzioni negative, cioè quelle che includono "not", seguono la regola "all". Questo significa che tutte le condizioni specificate in un'asserzione negativa devono essere verificate per dichiarare l'asserzione come riuscita. Ecco alcuni esempi:

should('not.exist'): Questa asserzione richiede che nessuno degli elementi selezionati esista. Deve essere vero per tutti gli elementi per superare l'asserzione.

should('not.be.visible'): Questa asserzione richiede che tutti gli elementi selezionati non siano visibili. Deve essere vero per tutti gli elementi per superare l'asserzione.

should('not.have.class', 'active'): Questa asserzione richiede che nessuno degli elementi selezionati abbia la classe 'active'. Deve essere vero per tutti gli elementi per superare l'asserzione.

Regola "Any" - Asserzioni Positive
Le asserzioni positive, cioè quelle senza "not", seguono la regola "any". In questo caso, almeno uno degli elementi selezionati deve soddisfare la condizione specificata affinché l'asserzione sia considerata riuscita. Ecco alcuni esempi:

should('exist'): Questa asserzione passerà se almeno uno degli elementi selezionati esiste. In altre parole, se c'è almeno un elemento che esiste, l'asserzione passerà.

should('be.visible'): Questa asserzione passerà se almeno uno degli elementi selezionati è visibile. Se anche solo uno degli elementi è visibile, l'asserzione passerà.

should('have.value', 'example'): Questa asserzione passerà se almeno uno degli elementi selezionati ha un valore uguale a 'example'. Se anche solo uno degli elementi ha questo valore, l'asserzione passerà.

Applicazione alle Asserzioni Specifiche
Ora, consideriamo come queste regole si applicano ad alcune asserzioni specifiche:

should('have.focus'): Questa asserzione è valutata in "any" e passerà se almeno uno degli elementi ha il focus.

should('be.checked'): Questa asserzione è valutata in "any" e passerà se almeno una delle caselle di controllo è selezionata.

should('select', 'value'): Questa asserzione è valutata in "any" e passerà se almeno una delle opzioni di un elemento di selezione corrisponde al valore specificato.

In generale, questa distinzione tra "all" e "any" è una parte importante della logica di valutazione delle asserzioni in Cypress. Comprendere questa regola ti aiuterà a scrivere test più specifici e significativi.